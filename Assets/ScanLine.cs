using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.iOS;

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class ScanLine : MonoBehaviour {

	public int pointCount = 10;

	public GameObject cube;
	public float maxRayDistance = 30.0f;
	public LayerMask collisionLayer = 1 << 10;  //ARKitPlane layer
	Mesh mesh;
	// Use this for initialization
	void Start () {
		mesh = new Mesh();
    	GetComponent<MeshFilter>().mesh = mesh;
	}
	
	private void FixedUpdate() 
	{
		
		//Ray ray = Camera.main.ScreenPointToRay (new Vector3(Screen.width/2, Screen.height/2, 0));
		Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
		RaycastHit hit;
		
		//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
		//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
		if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) {
			//we're going to get the position from the contact point
			cube.transform.position = hit.point;
			
			//and the rotation from the transform of the plane collider
			cube.transform.rotation = hit.transform.rotation;
		}		
		

		// Vector3[] hitPositios = new Vector3[pointCount];
		// for(int i =0; i< pointCount; i++)
		// {
		// 	var screenPosition = Camera.main.ScreenToViewportPoint(new Vector3(Screen.width /2,  Screen.height - Screen.width /10*i, 0));
		// 	ARPoint point = new ARPoint {
		// 		x = screenPosition.x,
		// 		y = screenPosition.y
		// 	};

		// 	// prioritize reults types
		// 	ARHitTestResultType[] resultTypes = {
		// 		//ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingGeometry,
		// 		ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
		// 		// if you want to use infinite planes use this:
		// 		//ARHitTestResultType.ARHitTestResultTypeExistingPlane,
		// 		//ARHitTestResultType.ARHitTestResultTypeEstimatedHorizontalPlane, 
		// 		//ARHitTestResultType.ARHitTestResultTypeEstimatedVerticalPlane, 
		// 		//ARHitTestResultType.ARHitTestResultTypeFeaturePoint
		// 	}; 
			
			
		// 	Vector3 hitPos; 
		// 	foreach (ARHitTestResultType resultType in resultTypes)
		// 	{
		// 		if (HitTestPoint (point, resultType, out hitPos))
		// 		{		
		// 			hitPositios[i] = hitPos;			
		// 			break;
		// 		}
		// 	}			
		// }
		// CreateMesh(hitPositios);
	}
	bool HitTestPoint (ARPoint point, ARHitTestResultType resultTypes, out Vector3 hitPoint)
	{
		List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface ().HitTest (point, resultTypes);
		if (hitResults.Count > 0) {
			foreach (var hitResult in hitResults) {				
				hitPoint = UnityARMatrixOps.GetPosition (hitResult.worldTransform);				
				return true;
			}
		}
		hitPoint = new Vector3();
		return false;
	}

	void CreateMesh( Vector3[] points) {        
        int[] indecies = new int[points.Length];

        for(int i=0;i<points.Length;++i) {            
            indecies[i] = i;           
        } 

        mesh.vertices = points;
        mesh.SetIndices(indecies, MeshTopology.Lines, 0);

    }
}
